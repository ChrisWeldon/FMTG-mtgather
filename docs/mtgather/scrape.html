<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>mtgather.scrape API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>mtgather.scrape</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#TODO write docs to this

import sys, os
import requests, json, time
import pandas as pd
from datetime import date, datetime
import numpy as np
from bs4 import BeautifulSoup,  NavigableString, Tag

from mtgather import Card
from mtgather import Event

# @param set_url: string representing url of set
# @return array of Card objects: card are effectively empty aside from the manifest data
def getCardsBySet(set_url=&#34;/set/THB/theros-beyond-death/&#34;, rarities=[&#39;rare&#39;, &#39;mythic-rare&#39;]):
    url=&#39;https://www.echomtg.com&#39; + set_url
    headers = requests.utils.default_headers()
    headers.update({&#39;User-Agent&#39;:&#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/60.0.3112.113 Safari/537.36&#39;})
    page=requests.get(url,headers=headers)
    soup=BeautifulSoup(page.content,&#39;html.parser&#39;)

    data = []
    for card in soup.find(&#39;table&#39;, id=&#39;set-table&#39;).findAll(&#39;tr&#39;):
        if card.find(&#39;a&#39;, class_=&#39;list-item&#39;):
            data.append({&#39;title&#39;: card.find(&#39;a&#39;, class_=&#39;list-item&#39;).text,
                        &#39;url&#39;: card.find(&#39;a&#39;, class_=&#39;list-item&#39;)[&#39;href&#39;],
                        &#39;rarity&#39;: card[&#39;class&#39;][0],
                        &#39;id&#39;: card.find(&#39;a&#39;, class_=&#39;list-item&#39;)[&#39;href&#39;].split(&#39;/&#39;)[2],
                        &#39;set&#39;: set_url})

    return_cards = []
    for object in data:
        if object[&#39;rarity&#39;] in rarities:
            return_cards.append(Card(echo_id=object[&#39;id&#39;], title=object[&#39;title&#39;], rarity=object[&#39;rarity&#39;], set=object[&#39;set&#39;]))
    return return_cards

def getEventsDayOnePage(date = date.today(), format=&#39;standard&#39;):
    #FIXME sometimes there still might be multiple pages!!!

    url = &#39;https://www.mtggoldfish.com/deck_searches/create?utf8=âœ“&amp;deck_search%5Bname%5D=&amp;deck_search%5Bformat%5D=&#39;+format+&#39;&amp;deck_search%5Btypes%5D%5B%5D=&amp;deck_search%5Btypes%5D%5B%5D=tournament&amp;deck_search%5Bplayer%5D=&amp;deck_search%5Bdate_range%5D=&#39;+str(date.strftime(&#39;%m&#39;))+&#39;%2F&#39;+str(date.strftime(&#39;%d&#39;))+&#39;%2F&#39;+str(date.strftime(&#39;%Y&#39;))+&#39;+-+&#39;+str(date.strftime(&#39;%m&#39;))+&#39;%2F&#39;+str(date.strftime(&#39;%d&#39;))+&#39;%2F&#39;+str(date.strftime(&#39;%Y&#39;))+&#39;&amp;deck_search%5Bdeck_search_card_filters_attributes%5D%5B0%5D%5Bcard%5D=&amp;deck_search%5Bdeck_search_card_filters_attributes%5D%5B0%5D%5Bquantity%5D=1&amp;deck_search%5Bdeck_search_card_filters_attributes%5D%5B0%5D%5Btype%5D=maindeck&amp;deck_search%5Bdeck_search_card_filters_attributes%5D%5B1%5D%5Bcard%5D=&amp;deck_search%5Bdeck_search_card_filters_attributes%5D%5B1%5D%5Bquantity%5D=1&amp;deck_search%5Bdeck_search_card_filters_attributes%5D%5B1%5D%5Btype%5D=maindeck&amp;counter=2&amp;commit=Search&#39;

    headers = requests.utils.default_headers()
    headers.update({&#39;User-Agent&#39;:&#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/60.0.3112.113 Safari/537.36&#39;})
    page=requests.get(url,headers=headers)
    soup=BeautifulSoup(page.content,&#39;html.parser&#39;)

    if(page.status_code == 500):
        print(&#34;Status Code: 500&#34;)
        raise ServerError(page.status_code, &#34;Server Error&#34;)

    if(str(soup)==str(&#39;Throttled\n&#39;)):
        print(&#34;Throttled&#34;)
        raise ThrottleError(&#34;Throttled on MTG Goldfish&#34;)

    ## Probing for potential bug, will delete later
    try:
        total_pages = int(soup.find(&#39;div&#39;, class_=&#39;pagination&#39;).findAll(&#39;a&#39;)[-2].text)
        print(&#34;TOTAL PAGES: &#34;, total_pages)
    except Exception as e:
        #passing silently because this block should be removed after bug discovery
        pass

    tourns = {}
    table = soup.find(&#39;table&#39;, class_=&#39;table table-responsive table-striped&#39;)


    if table == None:
        return []
    for row in table.findAll(&#39;tr&#39;):
        try:
            id = row.findAll(&#39;td&#39;)[2].find(&#39;a&#39;)[&#39;href&#39;]
            if id not in tourns.keys():
                tourns[id] = row.findAll(&#39;td&#39;)[0].text
                print(id, &#34; : &#34;, tourns[id])
        except IndexError:
            continue

    return [Event(key, date=tourns[key], format=format) for key in tourns.keys()]

def getEventsDay(date = date.today(), format=&#39;standard&#39;):
    #FIXME sometimes there still might be multiple pages!!!

    url = &#39;https://www.mtggoldfish.com/deck_searches/create?utf8=âœ“&amp;deck_search%5Bname%5D=&amp;deck_search%5Bformat%5D=&#39;+format+&#39;&amp;deck_search%5Btypes%5D%5B%5D=&amp;deck_search%5Btypes%5D%5B%5D=tournament&amp;deck_search%5Bplayer%5D=&amp;deck_search%5Bdate_range%5D=&#39;+str(date.strftime(&#39;%m&#39;))+&#39;%2F&#39;+str(date.strftime(&#39;%d&#39;))+&#39;%2F&#39;+str(date.strftime(&#39;%Y&#39;))+&#39;+-+&#39;+str(date.strftime(&#39;%m&#39;))+&#39;%2F&#39;+str(date.strftime(&#39;%d&#39;))+&#39;%2F&#39;+str(date.strftime(&#39;%Y&#39;))+&#39;&amp;deck_search%5Bdeck_search_card_filters_attributes%5D%5B0%5D%5Bcard%5D=&amp;deck_search%5Bdeck_search_card_filters_attributes%5D%5B0%5D%5Bquantity%5D=1&amp;deck_search%5Bdeck_search_card_filters_attributes%5D%5B0%5D%5Btype%5D=maindeck&amp;deck_search%5Bdeck_search_card_filters_attributes%5D%5B1%5D%5Bcard%5D=&amp;deck_search%5Bdeck_search_card_filters_attributes%5D%5B1%5D%5Bquantity%5D=1&amp;deck_search%5Bdeck_search_card_filters_attributes%5D%5B1%5D%5Btype%5D=maindeck&amp;counter=2&amp;commit=Search&#39;
    print(url)
    headers = requests.utils.default_headers()
    headers.update({&#39;User-Agent&#39;:&#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/60.0.3112.113 Safari/537.36&#39;})

    tourns = {}
    while url!=None:

        page=requests.get(url,headers=headers)
        soup=BeautifulSoup(page.content,&#39;html.parser&#39;)

        if(page.status_code == 500):
            print(&#34;Status Code: 500&#34;)
            raise ServerError(page.status_code, &#34;Server Error&#34;)

        if(str(soup)==str(&#39;Throttled\n&#39;)):
            print(&#34;Throttled&#34;)
            raise ThrottleError(&#34;Throttled on MTG Goldfish&#34;)

        table = soup.find(&#39;table&#39;, class_=&#39;table table-striped&#39;)
        if table == None:
            break
        for row in table.findAll(&#39;tr&#39;):
            try:
                id = row.findAll(&#39;td&#39;)[2].find(&#39;a&#39;)[&#39;href&#39;]
                if id not in tourns.keys():
                    tourns[id] = row.findAll(&#39;td&#39;)[0].text
                    print(id, &#34; : &#34;, tourns[id])
            except IndexError:
                continue

        next = soup.find(&#39;a&#39;, class_=&#39;next_page&#39;)
        if next == None:
            url  = None
        else:
            url = &#39;https://www.mtggoldfish.com&#39; +next[&#39;href&#39;]


    return [Event(key, date=datetime.strptime(tourns[key], &#34;%Y-%m-%d&#34;), format=format) for key in tourns.keys()]

def getEventData(event):
    assert isinstance(event, Event)
    url=&#39;https://www.mtggoldfish.com&#39; + event.event_url
    headers = requests.utils.default_headers()
    headers.update({&#39;User-Agent&#39;:&#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/60.0.3112.113 Safari/537.36&#39;})
    page=requests.get(url,headers=headers)
    soup=BeautifulSoup(page.content,&#39;html.parser&#39;)

    if(page.status_code == 500):
        raise ServerError(page.status_code, &#34;Server Error: getEventData&#34;)

    if(str(soup)==str(&#39;Throttled\n&#39;)):
        raise ThrottleError(&#34;Throttled on MTG Goldfish&#34;)

    # try:
    print(url)
    deck_ids = [deck[&#39;data-deckid&#39;] for deck in soup.find(&#39;table&#39;,
    class_=&#39;table-tournament&#39;).findAll(&#39;tr&#39;, class_=&#39;tournament-decklist&#39;)]
    # except AttributeError as err:
        # return False

    return deck_ids

def getOccDataByEvent(event, deck_max = 16):
    if not isinstance(event, Event):
        print(&#34;event is Not instance of Event&#34;)
        return False
    if(event.isEmpty()):
        print(&#34;Warning: Event is empty&#34; )
    headers = requests.utils.default_headers()
    headers.update({&#39;User-Agent&#39;:&#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/60.0.3112.113 Safari/537.36&#39;})

    cards = {}
    # get occurance data per deck in event
    decks = event.decks

    if(deck_max != -1):
        decks = decks[:deck_max]
    for id in decks:
        url=&#39;https://www.mtggoldfish.com/deck/&#39;+id+&#39;#paper&#39;
        page=requests.get(url, headers=headers)
        soup = BeautifulSoup(page.content, &#39;html.parser&#39;)

        try: # No Errors pass Silently PEP 8
            if(page.status_code == 500):
                raise ServerError(page.status_code, &#34;Server Error&#34;)
        except ServerError as e:
            print(e)
            continue

        # TODO: Handle Bad Gateway 502
        if(str(soup)==str(&#39;Throttled\n&#39;)):
            raise ThrottleError(&#34;Throttled on MTG Goldfish&#34;)

        # deck is private. Not collecting data for private decks
        if &#39;private&#39; in str(soup.find(&#39;div&#39;, class_=&#39;alert alert-warning&#39;)):
            continue



        print(url)
        table = soup.find(&#39;table&#39;, class_=&#39;deck-view-deck-table&#39;)
        description = soup.find(&#39;p&#39;, class_=&#39;deck-container-information&#39;)
        place = description.findChildren()[1].nextSibling.strip()[2:]

        for tr in table.findAll(&#39;tr&#39;):
            qty = tr.find(&#39;td&#39;, class_=&#39;text-right&#39;)
            name = tr.find(&#39;a&#39;)
            if qty:
                name = name.text.strip()
                qty = int(qty.text.strip())
                if name not in cards.keys():
                    cards[name] = {&#39;raw&#39;: 0}
                    cards[name][&#39;raw&#39;] =qty #creating quantity for raw occurances
                    cards[name][place] = qty #creating quantity for occurances at that placement
                else:
                    cards[name][&#39;raw&#39;] = cards[name][&#39;raw&#39;] + qty
                    if place not in cards[name].keys():
                        cards[name][place] = qty
                    else:
                        cards[name][place] = cards[name][place] + qty

    return cards

def getPaperPriceByCard(card, foil=False, cutoff_date=None):
    assert isinstance(card, Card)
    if not foil:
        url=&#39;https://www.echomtg.com/cache/&#39;+str(card.echo_id)+&#39;.r.json&#39;
    else:
        url=&#39;https://www.echomtg.com/cache/&#39;+str(card.echo_id)+&#39;.f.json&#39;
    headers = requests.utils.default_headers()
    headers.update({&#39;User-Agent&#39;:&#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/60.0.3112.113 Safari/537.36&#39;})
    page=requests.get(url,headers=headers)

    price_array = page.json()
    for row in price_array:
        row[0] = datetime.fromtimestamp(int(row[0])/1000)

    df = pd.DataFrame(columns=[&#39;datetime&#39;, &#39;price&#39;], data=np.array(price_array))
    dates = pd.date_range(df[&#39;datetime&#39;].min(), date.today())
    dates = dates.to_frame(name=&#39;datetime&#39;)
    df = df.set_index(&#39;datetime&#39;)

    df = dates.join(df, on=&#39;datetime&#39;)
    df = df.set_index(&#39;datetime&#39;)
    df = df.ffill()
    return df

# must be patched, not working currently
def getMTGOPriceByCard(card, foil=False, proxies={}, headers= requests.utils.default_headers()):
    assert isinstance(card, Card)
    title = card.title
    formatted_title = title.replace(&#34; // &#34;, &#34; &#34;).replace(&#34; &#34;, &#34;-&#34;).replace(&#34;,&#34;, &#34;&#34;).replace(&#34;&#39;&#34;, &#34;&#34;).lower()
    url = &#39;https://www.goatbots.com/card/ajax_card?search_name=&#39; + formatted_title

    page=requests.get(url, headers = headers, proxies=proxies)
    print(page.status_code)
    if(page.status_code == 403):
        raise ForbiddenError(&#34;Goatbots revolked access to pricing history&#34;)
    versions = page.json()[1]

    #v[0] is the first entry a card versions pricing array, v[i][0] is the date in str
    version = versions[0]

    for v in versions:
        version_date = datetime.strptime(v[0][0], &#34;%m/%d/%Y&#34;).date()
        if(version_date &lt;= card.release_date):
            version = v
            break

    df = pd.DataFrame(columns=[&#39;datetime&#39;, &#39;price&#39;], data=np.array(version))
    df[&#39;datetime&#39;]  = pd.to_datetime(df[&#39;datetime&#39;])

    dates = pd.date_range(df[&#39;datetime&#39;].min(), date.today())
    dates = dates.to_frame(name=&#39;datetime&#39;)
    df = df.set_index(&#39;datetime&#39;)

    df = dates.join(df, on=&#39;datetime&#39;)
    df = df.set_index(&#39;datetime&#39;)
    df = df.ffill()
    return df</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="mtgather.scrape.getCardsBySet"><code class="name flex">
<span>def <span class="ident">getCardsBySet</span></span>(<span>set_url='/set/THB/theros-beyond-death/', rarities=['rare', 'mythic-rare'])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getCardsBySet(set_url=&#34;/set/THB/theros-beyond-death/&#34;, rarities=[&#39;rare&#39;, &#39;mythic-rare&#39;]):
    url=&#39;https://www.echomtg.com&#39; + set_url
    headers = requests.utils.default_headers()
    headers.update({&#39;User-Agent&#39;:&#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/60.0.3112.113 Safari/537.36&#39;})
    page=requests.get(url,headers=headers)
    soup=BeautifulSoup(page.content,&#39;html.parser&#39;)

    data = []
    for card in soup.find(&#39;table&#39;, id=&#39;set-table&#39;).findAll(&#39;tr&#39;):
        if card.find(&#39;a&#39;, class_=&#39;list-item&#39;):
            data.append({&#39;title&#39;: card.find(&#39;a&#39;, class_=&#39;list-item&#39;).text,
                        &#39;url&#39;: card.find(&#39;a&#39;, class_=&#39;list-item&#39;)[&#39;href&#39;],
                        &#39;rarity&#39;: card[&#39;class&#39;][0],
                        &#39;id&#39;: card.find(&#39;a&#39;, class_=&#39;list-item&#39;)[&#39;href&#39;].split(&#39;/&#39;)[2],
                        &#39;set&#39;: set_url})

    return_cards = []
    for object in data:
        if object[&#39;rarity&#39;] in rarities:
            return_cards.append(Card(echo_id=object[&#39;id&#39;], title=object[&#39;title&#39;], rarity=object[&#39;rarity&#39;], set=object[&#39;set&#39;]))
    return return_cards</code></pre>
</details>
</dd>
<dt id="mtgather.scrape.getEventData"><code class="name flex">
<span>def <span class="ident">getEventData</span></span>(<span>event)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getEventData(event):
    assert isinstance(event, Event)
    url=&#39;https://www.mtggoldfish.com&#39; + event.event_url
    headers = requests.utils.default_headers()
    headers.update({&#39;User-Agent&#39;:&#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/60.0.3112.113 Safari/537.36&#39;})
    page=requests.get(url,headers=headers)
    soup=BeautifulSoup(page.content,&#39;html.parser&#39;)

    if(page.status_code == 500):
        raise ServerError(page.status_code, &#34;Server Error: getEventData&#34;)

    if(str(soup)==str(&#39;Throttled\n&#39;)):
        raise ThrottleError(&#34;Throttled on MTG Goldfish&#34;)

    # try:
    print(url)
    deck_ids = [deck[&#39;data-deckid&#39;] for deck in soup.find(&#39;table&#39;,
    class_=&#39;table-tournament&#39;).findAll(&#39;tr&#39;, class_=&#39;tournament-decklist&#39;)]
    # except AttributeError as err:
        # return False

    return deck_ids</code></pre>
</details>
</dd>
<dt id="mtgather.scrape.getEventsDay"><code class="name flex">
<span>def <span class="ident">getEventsDay</span></span>(<span>date=datetime.date(2020, 11, 11), format='standard')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getEventsDay(date = date.today(), format=&#39;standard&#39;):
    #FIXME sometimes there still might be multiple pages!!!

    url = &#39;https://www.mtggoldfish.com/deck_searches/create?utf8=âœ“&amp;deck_search%5Bname%5D=&amp;deck_search%5Bformat%5D=&#39;+format+&#39;&amp;deck_search%5Btypes%5D%5B%5D=&amp;deck_search%5Btypes%5D%5B%5D=tournament&amp;deck_search%5Bplayer%5D=&amp;deck_search%5Bdate_range%5D=&#39;+str(date.strftime(&#39;%m&#39;))+&#39;%2F&#39;+str(date.strftime(&#39;%d&#39;))+&#39;%2F&#39;+str(date.strftime(&#39;%Y&#39;))+&#39;+-+&#39;+str(date.strftime(&#39;%m&#39;))+&#39;%2F&#39;+str(date.strftime(&#39;%d&#39;))+&#39;%2F&#39;+str(date.strftime(&#39;%Y&#39;))+&#39;&amp;deck_search%5Bdeck_search_card_filters_attributes%5D%5B0%5D%5Bcard%5D=&amp;deck_search%5Bdeck_search_card_filters_attributes%5D%5B0%5D%5Bquantity%5D=1&amp;deck_search%5Bdeck_search_card_filters_attributes%5D%5B0%5D%5Btype%5D=maindeck&amp;deck_search%5Bdeck_search_card_filters_attributes%5D%5B1%5D%5Bcard%5D=&amp;deck_search%5Bdeck_search_card_filters_attributes%5D%5B1%5D%5Bquantity%5D=1&amp;deck_search%5Bdeck_search_card_filters_attributes%5D%5B1%5D%5Btype%5D=maindeck&amp;counter=2&amp;commit=Search&#39;
    print(url)
    headers = requests.utils.default_headers()
    headers.update({&#39;User-Agent&#39;:&#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/60.0.3112.113 Safari/537.36&#39;})

    tourns = {}
    while url!=None:

        page=requests.get(url,headers=headers)
        soup=BeautifulSoup(page.content,&#39;html.parser&#39;)

        if(page.status_code == 500):
            print(&#34;Status Code: 500&#34;)
            raise ServerError(page.status_code, &#34;Server Error&#34;)

        if(str(soup)==str(&#39;Throttled\n&#39;)):
            print(&#34;Throttled&#34;)
            raise ThrottleError(&#34;Throttled on MTG Goldfish&#34;)

        table = soup.find(&#39;table&#39;, class_=&#39;table table-striped&#39;)
        if table == None:
            break
        for row in table.findAll(&#39;tr&#39;):
            try:
                id = row.findAll(&#39;td&#39;)[2].find(&#39;a&#39;)[&#39;href&#39;]
                if id not in tourns.keys():
                    tourns[id] = row.findAll(&#39;td&#39;)[0].text
                    print(id, &#34; : &#34;, tourns[id])
            except IndexError:
                continue

        next = soup.find(&#39;a&#39;, class_=&#39;next_page&#39;)
        if next == None:
            url  = None
        else:
            url = &#39;https://www.mtggoldfish.com&#39; +next[&#39;href&#39;]


    return [Event(key, date=datetime.strptime(tourns[key], &#34;%Y-%m-%d&#34;), format=format) for key in tourns.keys()]</code></pre>
</details>
</dd>
<dt id="mtgather.scrape.getEventsDayOnePage"><code class="name flex">
<span>def <span class="ident">getEventsDayOnePage</span></span>(<span>date=datetime.date(2020, 11, 11), format='standard')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getEventsDayOnePage(date = date.today(), format=&#39;standard&#39;):
    #FIXME sometimes there still might be multiple pages!!!

    url = &#39;https://www.mtggoldfish.com/deck_searches/create?utf8=âœ“&amp;deck_search%5Bname%5D=&amp;deck_search%5Bformat%5D=&#39;+format+&#39;&amp;deck_search%5Btypes%5D%5B%5D=&amp;deck_search%5Btypes%5D%5B%5D=tournament&amp;deck_search%5Bplayer%5D=&amp;deck_search%5Bdate_range%5D=&#39;+str(date.strftime(&#39;%m&#39;))+&#39;%2F&#39;+str(date.strftime(&#39;%d&#39;))+&#39;%2F&#39;+str(date.strftime(&#39;%Y&#39;))+&#39;+-+&#39;+str(date.strftime(&#39;%m&#39;))+&#39;%2F&#39;+str(date.strftime(&#39;%d&#39;))+&#39;%2F&#39;+str(date.strftime(&#39;%Y&#39;))+&#39;&amp;deck_search%5Bdeck_search_card_filters_attributes%5D%5B0%5D%5Bcard%5D=&amp;deck_search%5Bdeck_search_card_filters_attributes%5D%5B0%5D%5Bquantity%5D=1&amp;deck_search%5Bdeck_search_card_filters_attributes%5D%5B0%5D%5Btype%5D=maindeck&amp;deck_search%5Bdeck_search_card_filters_attributes%5D%5B1%5D%5Bcard%5D=&amp;deck_search%5Bdeck_search_card_filters_attributes%5D%5B1%5D%5Bquantity%5D=1&amp;deck_search%5Bdeck_search_card_filters_attributes%5D%5B1%5D%5Btype%5D=maindeck&amp;counter=2&amp;commit=Search&#39;

    headers = requests.utils.default_headers()
    headers.update({&#39;User-Agent&#39;:&#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/60.0.3112.113 Safari/537.36&#39;})
    page=requests.get(url,headers=headers)
    soup=BeautifulSoup(page.content,&#39;html.parser&#39;)

    if(page.status_code == 500):
        print(&#34;Status Code: 500&#34;)
        raise ServerError(page.status_code, &#34;Server Error&#34;)

    if(str(soup)==str(&#39;Throttled\n&#39;)):
        print(&#34;Throttled&#34;)
        raise ThrottleError(&#34;Throttled on MTG Goldfish&#34;)

    ## Probing for potential bug, will delete later
    try:
        total_pages = int(soup.find(&#39;div&#39;, class_=&#39;pagination&#39;).findAll(&#39;a&#39;)[-2].text)
        print(&#34;TOTAL PAGES: &#34;, total_pages)
    except Exception as e:
        #passing silently because this block should be removed after bug discovery
        pass

    tourns = {}
    table = soup.find(&#39;table&#39;, class_=&#39;table table-responsive table-striped&#39;)


    if table == None:
        return []
    for row in table.findAll(&#39;tr&#39;):
        try:
            id = row.findAll(&#39;td&#39;)[2].find(&#39;a&#39;)[&#39;href&#39;]
            if id not in tourns.keys():
                tourns[id] = row.findAll(&#39;td&#39;)[0].text
                print(id, &#34; : &#34;, tourns[id])
        except IndexError:
            continue

    return [Event(key, date=tourns[key], format=format) for key in tourns.keys()]</code></pre>
</details>
</dd>
<dt id="mtgather.scrape.getMTGOPriceByCard"><code class="name flex">
<span>def <span class="ident">getMTGOPriceByCard</span></span>(<span>card, foil=False, proxies={}, headers={'User-Agent': 'python-requests/2.24.0', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive'})</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getMTGOPriceByCard(card, foil=False, proxies={}, headers= requests.utils.default_headers()):
    assert isinstance(card, Card)
    title = card.title
    formatted_title = title.replace(&#34; // &#34;, &#34; &#34;).replace(&#34; &#34;, &#34;-&#34;).replace(&#34;,&#34;, &#34;&#34;).replace(&#34;&#39;&#34;, &#34;&#34;).lower()
    url = &#39;https://www.goatbots.com/card/ajax_card?search_name=&#39; + formatted_title

    page=requests.get(url, headers = headers, proxies=proxies)
    print(page.status_code)
    if(page.status_code == 403):
        raise ForbiddenError(&#34;Goatbots revolked access to pricing history&#34;)
    versions = page.json()[1]

    #v[0] is the first entry a card versions pricing array, v[i][0] is the date in str
    version = versions[0]

    for v in versions:
        version_date = datetime.strptime(v[0][0], &#34;%m/%d/%Y&#34;).date()
        if(version_date &lt;= card.release_date):
            version = v
            break

    df = pd.DataFrame(columns=[&#39;datetime&#39;, &#39;price&#39;], data=np.array(version))
    df[&#39;datetime&#39;]  = pd.to_datetime(df[&#39;datetime&#39;])

    dates = pd.date_range(df[&#39;datetime&#39;].min(), date.today())
    dates = dates.to_frame(name=&#39;datetime&#39;)
    df = df.set_index(&#39;datetime&#39;)

    df = dates.join(df, on=&#39;datetime&#39;)
    df = df.set_index(&#39;datetime&#39;)
    df = df.ffill()
    return df</code></pre>
</details>
</dd>
<dt id="mtgather.scrape.getOccDataByEvent"><code class="name flex">
<span>def <span class="ident">getOccDataByEvent</span></span>(<span>event, deck_max=16)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getOccDataByEvent(event, deck_max = 16):
    if not isinstance(event, Event):
        print(&#34;event is Not instance of Event&#34;)
        return False
    if(event.isEmpty()):
        print(&#34;Warning: Event is empty&#34; )
    headers = requests.utils.default_headers()
    headers.update({&#39;User-Agent&#39;:&#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/60.0.3112.113 Safari/537.36&#39;})

    cards = {}
    # get occurance data per deck in event
    decks = event.decks

    if(deck_max != -1):
        decks = decks[:deck_max]
    for id in decks:
        url=&#39;https://www.mtggoldfish.com/deck/&#39;+id+&#39;#paper&#39;
        page=requests.get(url, headers=headers)
        soup = BeautifulSoup(page.content, &#39;html.parser&#39;)

        try: # No Errors pass Silently PEP 8
            if(page.status_code == 500):
                raise ServerError(page.status_code, &#34;Server Error&#34;)
        except ServerError as e:
            print(e)
            continue

        # TODO: Handle Bad Gateway 502
        if(str(soup)==str(&#39;Throttled\n&#39;)):
            raise ThrottleError(&#34;Throttled on MTG Goldfish&#34;)

        # deck is private. Not collecting data for private decks
        if &#39;private&#39; in str(soup.find(&#39;div&#39;, class_=&#39;alert alert-warning&#39;)):
            continue



        print(url)
        table = soup.find(&#39;table&#39;, class_=&#39;deck-view-deck-table&#39;)
        description = soup.find(&#39;p&#39;, class_=&#39;deck-container-information&#39;)
        place = description.findChildren()[1].nextSibling.strip()[2:]

        for tr in table.findAll(&#39;tr&#39;):
            qty = tr.find(&#39;td&#39;, class_=&#39;text-right&#39;)
            name = tr.find(&#39;a&#39;)
            if qty:
                name = name.text.strip()
                qty = int(qty.text.strip())
                if name not in cards.keys():
                    cards[name] = {&#39;raw&#39;: 0}
                    cards[name][&#39;raw&#39;] =qty #creating quantity for raw occurances
                    cards[name][place] = qty #creating quantity for occurances at that placement
                else:
                    cards[name][&#39;raw&#39;] = cards[name][&#39;raw&#39;] + qty
                    if place not in cards[name].keys():
                        cards[name][place] = qty
                    else:
                        cards[name][place] = cards[name][place] + qty

    return cards</code></pre>
</details>
</dd>
<dt id="mtgather.scrape.getPaperPriceByCard"><code class="name flex">
<span>def <span class="ident">getPaperPriceByCard</span></span>(<span>card, foil=False, cutoff_date=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getPaperPriceByCard(card, foil=False, cutoff_date=None):
    assert isinstance(card, Card)
    if not foil:
        url=&#39;https://www.echomtg.com/cache/&#39;+str(card.echo_id)+&#39;.r.json&#39;
    else:
        url=&#39;https://www.echomtg.com/cache/&#39;+str(card.echo_id)+&#39;.f.json&#39;
    headers = requests.utils.default_headers()
    headers.update({&#39;User-Agent&#39;:&#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/60.0.3112.113 Safari/537.36&#39;})
    page=requests.get(url,headers=headers)

    price_array = page.json()
    for row in price_array:
        row[0] = datetime.fromtimestamp(int(row[0])/1000)

    df = pd.DataFrame(columns=[&#39;datetime&#39;, &#39;price&#39;], data=np.array(price_array))
    dates = pd.date_range(df[&#39;datetime&#39;].min(), date.today())
    dates = dates.to_frame(name=&#39;datetime&#39;)
    df = df.set_index(&#39;datetime&#39;)

    df = dates.join(df, on=&#39;datetime&#39;)
    df = df.set_index(&#39;datetime&#39;)
    df = df.ffill()
    return df</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="mtgather" href="index.html">mtgather</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="mtgather.scrape.getCardsBySet" href="#mtgather.scrape.getCardsBySet">getCardsBySet</a></code></li>
<li><code><a title="mtgather.scrape.getEventData" href="#mtgather.scrape.getEventData">getEventData</a></code></li>
<li><code><a title="mtgather.scrape.getEventsDay" href="#mtgather.scrape.getEventsDay">getEventsDay</a></code></li>
<li><code><a title="mtgather.scrape.getEventsDayOnePage" href="#mtgather.scrape.getEventsDayOnePage">getEventsDayOnePage</a></code></li>
<li><code><a title="mtgather.scrape.getMTGOPriceByCard" href="#mtgather.scrape.getMTGOPriceByCard">getMTGOPriceByCard</a></code></li>
<li><code><a title="mtgather.scrape.getOccDataByEvent" href="#mtgather.scrape.getOccDataByEvent">getOccDataByEvent</a></code></li>
<li><code><a title="mtgather.scrape.getPaperPriceByCard" href="#mtgather.scrape.getPaperPriceByCard">getPaperPriceByCard</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>